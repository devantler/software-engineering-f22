/*
 * generated by Xtext 2.25.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.factoryLogicLang.Camera;
import xtext.factoryLogicLang.CameraParameter;
import xtext.factoryLogicLang.CameraScan;
import xtext.factoryLogicLang.Conditional;
import xtext.factoryLogicLang.Crane;
import xtext.factoryLogicLang.CraneDrop;
import xtext.factoryLogicLang.CraneParameter;
import xtext.factoryLogicLang.CranePickup;
import xtext.factoryLogicLang.FactoryLogicLangPackage;
import xtext.factoryLogicLang.Loop;
import xtext.factoryLogicLang.Model;
import xtext.factoryLogicLang.Storage;
import xtext.factoryLogicLang.StorageMarkSlot;
import xtext.factoryLogicLang.StorageMoveEmptySlot;
import xtext.factoryLogicLang.StorageMoveSlot;
import xtext.factoryLogicLang.StoragePositionParameter;
import xtext.factoryLogicLang.StorageSlotParameter;
import xtext.services.FactoryLogicLangGrammarAccess;

@SuppressWarnings("all")
public class FactoryLogicLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FactoryLogicLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FactoryLogicLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FactoryLogicLangPackage.CAMERA:
				sequence_Camera(context, (Camera) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CAMERA_PARAMETER:
				sequence_CameraParameter(context, (CameraParameter) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CAMERA_SCAN:
				sequence_CameraScan(context, (CameraScan) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CONDITIONAL:
				sequence_Conditional(context, (Conditional) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CRANE:
				sequence_Crane(context, (Crane) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CRANE_DROP:
				sequence_CraneDrop(context, (CraneDrop) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CRANE_PARAMETER:
				sequence_CraneParameter(context, (CraneParameter) semanticObject); 
				return; 
			case FactoryLogicLangPackage.CRANE_PICKUP:
				sequence_CranePickup(context, (CranePickup) semanticObject); 
				return; 
			case FactoryLogicLangPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case FactoryLogicLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE:
				sequence_Storage(context, (Storage) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE_MARK_SLOT:
				sequence_StorageMarkSlot(context, (StorageMarkSlot) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE_MOVE_EMPTY_SLOT:
				sequence_StorageMoveEmptySlot(context, (StorageMoveEmptySlot) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE_MOVE_SLOT:
				sequence_StorageMoveSlot(context, (StorageMoveSlot) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE_POSITION_PARAMETER:
				sequence_StoragePositionParameter(context, (StoragePositionParameter) semanticObject); 
				return; 
			case FactoryLogicLangPackage.STORAGE_SLOT_PARAMETER:
				sequence_StorageSlotParameter(context, (StorageSlotParameter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CameraParameter returns CameraParameter
	 *
	 * Constraint:
	 *     color=COLOR
	 */
	protected void sequence_CameraParameter(ISerializationContext context, CameraParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_PARAMETER__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_PARAMETER__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCameraParameterAccess().getColorCOLOREnumRuleCall_2_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns CameraScan
	 *     Logic returns CameraScan
	 *     Operation returns CameraScan
	 *     CameraScan returns CameraScan
	 *
	 * Constraint:
	 *     (device=[Camera|ID] name=ID)
	 */
	protected void sequence_CameraScan(ISerializationContext context, CameraScan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_SCAN__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_SCAN__DEVICE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_SCAN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CAMERA_SCAN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCameraScanAccess().getDeviceCameraIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.CAMERA_SCAN__DEVICE, false));
		feeder.accept(grammarAccess.getCameraScanAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Camera
	 *     Device returns Camera
	 *     Camera returns Camera
	 *
	 * Constraint:
	 *     (name=STRING parameters+=CameraParameter+)
	 */
	protected void sequence_Camera(ISerializationContext context, Camera semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Conditional
	 *     Logic returns Conditional
	 *     Conditional returns Conditional
	 *
	 * Constraint:
	 *     (
	 *         variable=ID 
	 *         source=[Device|ID]? 
	 *         operator=BOOLEAN_OPERATOR? 
	 *         (comparison_const=CONST_VARIABLES | comparison_color=COLOR | comparison_int=INT) 
	 *         logics+=Logic+
	 *     )
	 */
	protected void sequence_Conditional(ISerializationContext context, Conditional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns CraneDrop
	 *     Logic returns CraneDrop
	 *     Operation returns CraneDrop
	 *     CraneDrop returns CraneDrop
	 *
	 * Constraint:
	 *     (device=[Crane|ID] location=[CraneParameter|ID])
	 */
	protected void sequence_CraneDrop(ISerializationContext context, CraneDrop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_DROP__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_DROP__DEVICE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_DROP__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_DROP__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCraneDropAccess().getDeviceCraneIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.CRANE_DROP__DEVICE, false));
		feeder.accept(grammarAccess.getCraneDropAccess().getLocationCraneParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.CRANE_DROP__LOCATION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CraneParameter returns CraneParameter
	 *
	 * Constraint:
	 *     (degree=INT name=STRING)
	 */
	protected void sequence_CraneParameter(ISerializationContext context, CraneParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PARAMETER__DEGREE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PARAMETER__DEGREE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCraneParameterAccess().getDegreeINTTerminalRuleCall_3_0(), semanticObject.getDegree());
		feeder.accept(grammarAccess.getCraneParameterAccess().getNameSTRINGTerminalRuleCall_5_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns CranePickup
	 *     Logic returns CranePickup
	 *     Operation returns CranePickup
	 *     CranePickup returns CranePickup
	 *
	 * Constraint:
	 *     (device=[Crane|ID] location=[CraneParameter|ID])
	 */
	protected void sequence_CranePickup(ISerializationContext context, CranePickup semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PICKUP__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PICKUP__DEVICE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PICKUP__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.CRANE_PICKUP__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCranePickupAccess().getDeviceCraneIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.CRANE_PICKUP__DEVICE, false));
		feeder.accept(grammarAccess.getCranePickupAccess().getLocationCraneParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.CRANE_PICKUP__LOCATION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Crane
	 *     Device returns Crane
	 *     Crane returns Crane
	 *
	 * Constraint:
	 *     (name=STRING parameters+=CraneParameter+)
	 */
	protected void sequence_Crane(ISerializationContext context, Crane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Loop
	 *     Logic returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         list=ID 
	 *         source=[Device|ID]? 
	 *         operator=BOOLEAN_OPERATOR? 
	 *         (comparison_const=CONST_VARIABLES | comparison_color=COLOR | comparison_int=INT) 
	 *         logics+=Logic+
	 *     )
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     declarations+=Declaration+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns StorageMarkSlot
	 *     Logic returns StorageMarkSlot
	 *     Operation returns StorageMarkSlot
	 *     StorageMarkSlot returns StorageMarkSlot
	 *
	 * Constraint:
	 *     (
	 *         device=[Storage|ID] 
	 *         position=[StoragePositionParameter|ID] 
	 *         (comparison_const=CONST_VARIABLES | comparison_color=COLOR | comparison_int=INT) 
	 *         (quantity=INT measure=TIME)?
	 *     )
	 */
	protected void sequence_StorageMarkSlot(ISerializationContext context, StorageMarkSlot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns StorageMoveEmptySlot
	 *     Logic returns StorageMoveEmptySlot
	 *     Operation returns StorageMoveEmptySlot
	 *     StorageMoveEmptySlot returns StorageMoveEmptySlot
	 *
	 * Constraint:
	 *     (device=[Storage|ID] destination=[StoragePositionParameter|ID])
	 */
	protected void sequence_StorageMoveEmptySlot(ISerializationContext context, StorageMoveEmptySlot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DEVICE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DESTINATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStorageMoveEmptySlotAccess().getDeviceStorageIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DEVICE, false));
		feeder.accept(grammarAccess.getStorageMoveEmptySlotAccess().getDestinationStoragePositionParameterIDTerminalRuleCall_5_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.STORAGE_MOVE_EMPTY_SLOT__DESTINATION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns StorageMoveSlot
	 *     Logic returns StorageMoveSlot
	 *     Operation returns StorageMoveSlot
	 *     StorageMoveSlot returns StorageMoveSlot
	 *
	 * Constraint:
	 *     (device=[Storage|ID] position=[StoragePositionParameter|ID] destination=[StoragePositionParameter|ID])
	 */
	protected void sequence_StorageMoveSlot(ISerializationContext context, StorageMoveSlot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DEVICE));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__POSITION));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DESTINATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStorageMoveSlotAccess().getDeviceStorageIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DEVICE, false));
		feeder.accept(grammarAccess.getStorageMoveSlotAccess().getPositionStoragePositionParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__POSITION, false));
		feeder.accept(grammarAccess.getStorageMoveSlotAccess().getDestinationStoragePositionParameterIDTerminalRuleCall_6_0_1(), semanticObject.eGet(FactoryLogicLangPackage.Literals.STORAGE_MOVE_SLOT__DESTINATION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StorageParameter returns StoragePositionParameter
	 *     StoragePositionParameter returns StoragePositionParameter
	 *
	 * Constraint:
	 *     (slot=INT name=STRING)
	 */
	protected void sequence_StoragePositionParameter(ISerializationContext context, StoragePositionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_POSITION_PARAMETER__SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_POSITION_PARAMETER__SLOT));
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_POSITION_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_POSITION_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStoragePositionParameterAccess().getSlotINTTerminalRuleCall_4_0(), semanticObject.getSlot());
		feeder.accept(grammarAccess.getStoragePositionParameterAccess().getNameSTRINGTerminalRuleCall_6_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StorageParameter returns StorageSlotParameter
	 *     StorageSlotParameter returns StorageSlotParameter
	 *
	 * Constraint:
	 *     slots=INT
	 */
	protected void sequence_StorageSlotParameter(ISerializationContext context, StorageSlotParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_SLOT_PARAMETER__SLOTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryLogicLangPackage.Literals.STORAGE_SLOT_PARAMETER__SLOTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStorageSlotParameterAccess().getSlotsINTTerminalRuleCall_1_0(), semanticObject.getSlots());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Storage
	 *     Device returns Storage
	 *     Storage returns Storage
	 *
	 * Constraint:
	 *     (name=STRING parameters+=StorageParameter+)
	 */
	protected void sequence_Storage(ISerializationContext context, Storage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
